<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PseudoLuX</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #000000 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: 
                radial-gradient(circle at 20% 30%, rgba(70, 130, 180, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(169, 169, 169, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 40% 80%, rgba(135, 206, 235, 0.06) 0%, transparent 60%),
                #0a0a0a;
        }


        .progress-gauge {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            z-index: 10;
        }

        .gauge-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #ff0000 0%, #ffff00 33%, #00ff00 66%, #ffffff 100%);
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gauge-inner {
            width: calc(100% - 16px);
            height: calc(100% - 16px);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
        }

        .gauge-percentage {
            font-size: 18px;
            margin-bottom: 4px;
        }

        .settings-icon {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: white;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .settings-icon:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .settings-panel {
            position: absolute;
            bottom: 80px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            z-index: 10;
            min-width: 200px;
            display: none;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
        }

        .setting-label {
            color: rgba(255, 255, 255, 0.8);
            margin-right: 10px;
        }

        .setting-slider {
            flex: 1;
            margin: 0 8px;
        }

        .setting-value {
            color: rgba(255, 255, 255, 1);
            min-width: 30px;
            text-align: center;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .help-icon {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: white;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .help-icon:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .instructions {
            position: absolute;
            bottom: 80px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            max-width: 300px;
            line-height: 1.4;
            z-index: 10;
            display: none;
        }

        .victory-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            text-align: center;
            z-index: 20;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            display: none;
        }


        .replay-button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .replay-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .instructions, .settings-panel {
                font-size: 11px;
                padding: 10px;
            }
            .settings-panel {
                min-width: 160px;
            }
            .progress-gauge {
                width: 100px;
                height: 100px;
            }
            .gauge-percentage {
                font-size: 16px;
            }
            .settings-icon, .help-icon {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="progress-gauge">
        <div class="gauge-circle">
            <div class="gauge-inner">
                <div class="gauge-percentage" id="whiteProgress">0%</div>
                <div style="font-size: 10px; opacity: 0.8;">BLANC</div>
            </div>
        </div>
    </div>

    <div class="settings-icon" id="settingsIcon">‚öôÔ∏è</div>
    <div class="settings-panel" id="settingsPanel">
        <div style="text-align: center; margin-bottom: 10px; font-weight: bold;">‚öôÔ∏è R√âGLAGES</div>
        
        <div class="setting-row">
            <span class="setting-label">Attraction:</span>
            <input type="range" id="attractionSlider" min="0" max="100" value="50" class="setting-slider">
            <span id="attractionValue" class="setting-value">50</span>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">Port√©e:</span>
            <input type="range" id="rangeSlider" min="50" max="400" value="200" class="setting-slider">
            <span id="rangeValue" class="setting-value">200</span>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">Fusion:</span>
            <input type="range" id="fusionSlider" min="1" max="10" value="5" class="setting-slider">
            <span id="fusionValue" class="setting-value">5</span>
        </div>
        
        <div style="margin-top: 15px; text-align: center;">
            <button id="autoPlayBtn" style="
                background: linear-gradient(45deg, #4CAF50, #45a049);
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 11px;
                transition: all 0.3s ease;
            ">ü§ñ MODE AUTO</button>
        </div>
    </div>

    <div class="help-icon" id="helpIcon">?</div>
    <div class="instructions" id="instructionsPanel">
        <div style="font-weight: bold; margin-bottom: 10px;">COMMENT JOUER</div>
        Fusionnez les couleurs primaires (R,G,B) pour cr√©er du blanc.<br><br>
        <strong>Contr√¥les:</strong><br>
        ‚Ä¢ Glisser: d√©placer les particules<br>
        ‚Ä¢ Double-clic: exploser une particule en 2<br>
        ‚Ä¢ Clic droit: cr√©er une nouvelle particule<br>
        ‚Ä¢ Mobile: glisser/double-taper<br><br>
        <strong>Objectif:</strong> Atteindre 100% de blanc!
    </div>

    <div class="victory-panel" id="victoryPanel">
        <div style="font-size: 32px; font-weight: 300; letter-spacing: 3px; margin-bottom: 20px;">PseudoLuX</div>
        <button class="replay-button" id="replayButton">üîÑ</button>
    </div>

    <script>
        class Particle {
            constructor(x, y, options = {}) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                
                this.density = options.density || 0.5; // All particles start same density
                this.charge = options.charge || (Math.random() - 0.5) * 2;
                this.potential = options.potential || Math.random();
                
                this.radius = this.density * 30 + 10; // All start at radius 25
                this.mass = this.density * this.radius;
                
                // RGB color system instead of HSL
                if (options.color) {
                    this.r = options.color.r;
                    this.g = options.color.g;
                    this.b = options.color.b;
                } else {
                    const primaryColors = [
                        {r: 255, g: 0, b: 0},    // Red
                        {r: 0, g: 255, b: 0},    // Green
                        {r: 0, g: 0, b: 255},    // Blue
                        {r: 255, g: 255, b: 0},  // Yellow
                        {r: 255, g: 0, b: 255},  // Magenta
                        {r: 0, g: 255, b: 255}   // Cyan
                    ];
                    const color = primaryColors[Math.floor(Math.random() * primaryColors.length)];
                    this.r = color.r;
                    this.g = color.g;
                    this.b = color.b;
                }
                
                this.alpha = this.potential * 0.6 + 0.4;
                
                this.isDragging = false;
                this.energy = 1.0;
                this.lastInteraction = 0;
                
                this.oscillation = Math.random() * Math.PI * 2;
                this.oscillationSpeed = Math.random() * 0.02 + 0.01;
            }

            getColorString() {
                const intensity = this.energy * 0.6 + 0.8; // Much brighter: 0.8 to 1.4
                return `rgba(${Math.round(this.r * intensity)}, ${Math.round(this.g * intensity)}, ${Math.round(this.b * intensity)}, ${this.alpha})`;
            }

            getWhiteness() {
                const total = this.r + this.g + this.b;
                if (total === 0) return 0;
                
                // Calculate balance: how close R, G, B are to each other
                const min = Math.min(this.r, this.g, this.b);
                const max = Math.max(this.r, this.g, this.b);
                
                // Perfect balance = min/max = 1, poor balance = min/max close to 0
                const balance = max === 0 ? 0 : min / max;
                
                // Brightness factor: how intense the color is overall (more generous)
                const brightness = Math.min(1, total / (3 * 80)); // Lower threshold for brightness
                
                // White = balance is key, brightness boost starts at 50%
                return balance * (0.5 + brightness * 0.5);
            }

            update(deltaTime, allParticles, gameWon = false) {
                if (!this.isDragging) {
                    if (gameWon) {
                        // Victory mode: white particle moves randomly and grows
                        // Random movement
                        this.vx += (Math.random() - 0.5) * 0.05;
                        this.vy += (Math.random() - 0.5) * 0.05;
                        
                        // Rapidly grow in victory mode
                        this.density += 0.01;
                        this.radius = this.density * 30 + 10;
                        this.mass = this.density * this.radius;
                        
                        // Limit velocity for smooth movement
                        const maxSpeed = 1.5;
                        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        if (speed > maxSpeed) {
                            this.vx = (this.vx / speed) * maxSpeed;
                            this.vy = (this.vy / speed) * maxSpeed;
                        }
                        
                        this.x += this.vx;
                        this.y += this.vy;
                        
                        // Bounce off walls
                        if (this.x < this.radius || this.x > canvas.width - this.radius) {
                            this.vx *= -0.8;
                            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                        }
                        if (this.y < this.radius || this.y > canvas.height - this.radius) {
                            this.vy *= -0.8;
                            this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                        }
                        
                        return;
                    }
                    
                    const speedMultiplier = autoPlay ? 10 : 1; // 10x speed in auto mode
                    
                    this.vx *= 0.99;
                    this.vy *= 0.99;
                    
                    // Gravitational attraction to bigger particles
                    allParticles.forEach(other => {
                        if (other !== this && other.mass > this.mass) {
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 0 && distance < attractionRange) { // Attraction range
                                const massRatio = other.mass / this.mass;
                                const force = (massRatio * 0.0001 * attractionIntensity * speedMultiplier) / (distance * distance + 1);
                                
                                this.vx += (dx / distance) * force;
                                this.vy += (dy / distance) * force;
                            }
                        }
                    });
                    
                    this.oscillation += this.oscillationSpeed * speedMultiplier;
                    this.vx += Math.sin(this.oscillation) * 0.01 * speedMultiplier;
                    this.vy += Math.cos(this.oscillation * 1.3) * 0.01 * speedMultiplier;
                    
                    this.x += this.vx * speedMultiplier;
                    this.y += this.vy * speedMultiplier;
                    
                    if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.8; }
                    if (this.x > canvas.width - this.radius) { this.x = canvas.width - this.radius; this.vx *= -0.8; }
                    if (this.y < this.radius) { this.y = this.radius; this.vy *= -0.8; }
                    if (this.y > canvas.height - this.radius) { this.y = canvas.height - this.radius; this.vy *= -0.8; }
                }
                
                this.energy = Math.max(0.5, this.energy - 0.00005);
                this.lastInteraction = Math.max(0, this.lastInteraction - deltaTime);
            }

            draw(ctx) {
                const currentRadius = this.radius * (0.8 + Math.sin(this.oscillation) * 0.2);
                const glowIntensity = this.energy * 0.4 + 0.8; // Brighter glow
                
                ctx.save();
                
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, currentRadius * 1.5
                );
                
                const coreColor = this.getColorString();
                const edgeR = Math.round(this.r * glowIntensity * 0.6);
                const edgeG = Math.round(this.g * glowIntensity * 0.6);
                const edgeB = Math.round(this.b * glowIntensity * 0.6);
                
                gradient.addColorStop(0, coreColor);
                gradient.addColorStop(0.7, `rgba(${edgeR}, ${edgeG}, ${edgeB}, ${this.alpha * 0.3})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.lastInteraction > 0) {
                    const interactionAlpha = this.lastInteraction / 1000;
                    ctx.strokeStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${interactionAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentRadius * (2 - interactionAlpha), 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Show whiteness indicator for very white particles
                const whiteness = this.getWhiteness();
                if (whiteness > 0.8) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${whiteness - 0.8})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentRadius * 1.8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            distanceTo(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }

            interactWith(other) {
                const distance = this.distanceTo(other);
                const interactionRadius = this.radius + other.radius;
                
                if (distance < interactionRadius) {
                    this.lastInteraction = 500;
                    other.lastInteraction = 500;
                    
                    const similarity = Math.abs(this.density - other.density) + 
                                    Math.abs(this.charge - other.charge) + 
                                    Math.abs(this.potential - other.potential);
                    
                    if (similarity < 0.8 && Math.random() < fusionProbability) {
                        return this.fuse(other);
                    } else if (false) {
                        // Removed automatic splitting
                    } else {
                        this.mutate(other);
                        other.mutate(this);
                    }
                }
                return null;
            }

            fuse(other) {
                const totalMass = this.mass + other.mass;
                const weight1 = this.mass / totalMass;
                const weight2 = other.mass / totalMass;
                
                // Additive color mixing (like light)
                const newR = Math.min(255, Math.round(this.r * weight1 + other.r * weight2));
                const newG = Math.min(255, Math.round(this.g * weight1 + other.g * weight2));
                const newB = Math.min(255, Math.round(this.b * weight1 + other.b * weight2));
                
                // New size = sum of both densities (conservation of matter)
                const newDensity = this.density + other.density;
                
                const newParticle = new Particle(
                    (this.x + other.x) / 2,
                    (this.y + other.y) / 2,
                    {
                        density: newDensity,
                        charge: (this.charge + other.charge) / 2,
                        potential: Math.min(1, (this.potential + other.potential) * 1.2),
                        color: { r: newR, g: newG, b: newB }
                    }
                );
                newParticle.energy = Math.min(1, this.energy + other.energy);
                return { type: 'fusion', newParticle, removeParticles: [this, other] };
            }

            explode() {
                // Only split if particle is big enough (density > 1.0)
                if (this.density <= 1.0) return null;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = this.radius;
                
                // Split density exactly in half
                const halfDensity = this.density / 2;
                
                const particle1 = new Particle(
                    this.x + Math.cos(angle) * distance,
                    this.y + Math.sin(angle) * distance,
                    {
                        density: halfDensity,
                        charge: this.charge,
                        potential: this.potential,
                        color: { r: this.r, g: this.g, b: this.b }
                    }
                );
                
                const particle2 = new Particle(
                    this.x - Math.cos(angle) * distance,
                    this.y - Math.sin(angle) * distance,
                    {
                        density: halfDensity,
                        charge: this.charge,
                        potential: this.potential,
                        color: { r: this.r, g: this.g, b: this.b }
                    }
                );
                
                // Give them some initial velocity away from each other
                particle1.vx = Math.cos(angle) * 0.5;
                particle1.vy = Math.sin(angle) * 0.5;
                particle2.vx = -Math.cos(angle) * 0.5;
                particle2.vy = -Math.sin(angle) * 0.5;
                
                return { type: 'explosion', newParticles: [particle1, particle2], removeParticles: [this] };
            }

            mutate(other) {
                const influence = 0.03;
                this.density += (other.density - this.density) * influence;
                this.charge += (other.charge - this.charge) * influence;
                this.potential += (other.potential - this.potential) * influence;
                
                // Color mutation with slight blending
                this.r = Math.max(0, Math.min(255, this.r + (other.r - this.r) * influence));
                this.g = Math.max(0, Math.min(255, this.g + (other.g - this.g) * influence));
                this.b = Math.max(0, Math.min(255, this.b + (other.b - this.b) * influence));
                
                this.potential = Math.max(0, Math.min(1, this.potential));
                this.density = Math.max(0.1, Math.min(1, this.density));
                this.charge = Math.max(-2, Math.min(2, this.charge));
                
                this.radius = this.density * 30 + 10;
                this.energy = Math.min(1, this.energy + 0.1);
            }

            containsPoint(x, y) {
                return this.distanceTo({ x, y }) < this.radius;
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.interactions = 0;
                this.time = 0;
                this.whitestParticle = null;
                this.bestWhiteness = 0;
                this.gameWon = false;
                
                for (let i = 0; i < 6; i++) {
                    this.createPrimaryColorParticle();
                }
            }

            createPrimaryColorParticle() {
                const margin = 100;
                const x = margin + Math.random() * (canvas.width - 2 * margin);
                const y = margin + Math.random() * (canvas.height - 2 * margin);
                
                const primaryColors = [
                    {r: 255, g: 0, b: 0},    // Red
                    {r: 0, g: 255, b: 0},    // Green
                    {r: 0, g: 0, b: 255},    // Blue
                ];
                const color = primaryColors[Math.floor(Math.random() * primaryColors.length)];
                
                this.particles.push(new Particle(x, y, {
                    density: 0.5, // All particles same size
                    color: color
                }));
            }

            createRandomParticle() {
                const margin = 100;
                const x = margin + Math.random() * (canvas.width - 2 * margin);
                const y = margin + Math.random() * (canvas.height - 2 * margin);
                this.particles.push(new Particle(x, y));
            }

            update(deltaTime) {
                this.time += deltaTime;
                
                this.particles.forEach(particle => particle.update(deltaTime, this.particles, this.gameWon));
                
                // Stop interactions and particle creation when game is won
                if (!this.gameWon) {
                    for (let i = 0; i < this.particles.length; i++) {
                        for (let j = i + 1; j < this.particles.length; j++) {
                            const result = this.particles[i].interactWith(this.particles[j]);
                            if (result) {
                                this.handleInteraction(result);
                            }
                        }
                    }
                    
                    // Check for whiteness and win condition
                    this.updateWhitenessTracking();
                    
                    // Occasionally spawn new primary color particles
                    if (Math.random() < 0.002 && this.particles.length < 15) {
                        this.createPrimaryColorParticle();
                    }
                    
                    // Auto-play behavior - more frequent actions in auto mode
                    if (autoPlay && Math.random() < 0.05) {
                        this.performAutoAction();
                    }
                }
            }

            updateWhitenessTracking() {
                this.bestWhiteness = 0;
                this.whitestParticle = null;
                
                this.particles.forEach(particle => {
                    const whiteness = particle.getWhiteness();
                    if (whiteness > this.bestWhiteness) {
                        this.bestWhiteness = whiteness;
                        this.whitestParticle = particle;
                    }
                });
                
                // Check win condition - more lenient threshold
                if (this.bestWhiteness > 0.85 && !this.gameWon) {
                    this.gameWon = true;
                    this.showVictory();
                    // Stop auto-play when winning
                    autoPlay = false;
                    $('#autoPlayBtn').text('ü§ñ MODE AUTO');
                    $('#autoPlayBtn').css('background', 'linear-gradient(45deg, #4CAF50, #45a049)');
                }
            }

            showVictory() {
                document.getElementById('victoryPanel').style.display = 'block';
                
                // Immediately keep only the whitest particle
                if (this.whitestParticle) {
                    this.particles = [this.whitestParticle];
                    
                    // Position white particle in center and boost it
                    this.whitestParticle.x = canvas.width / 2;
                    this.whitestParticle.y = canvas.height / 2;
                    this.whitestParticle.vx = 0;
                    this.whitestParticle.vy = 0;
                    this.whitestParticle.energy = 2.0;
                } else {
                    // If no white particle found, create one in center
                    this.particles = [new Particle(canvas.width / 2, canvas.height / 2, {
                        density: 2.0,
                        color: { r: 255, g: 255, b: 255 }
                    })];
                }
            }

            resetGame() {
                this.particles = [];
                this.interactions = 0;
                this.time = 0;
                this.whitestParticle = null;
                this.bestWhiteness = 0;
                this.gameWon = false;
                
                // Create initial particles
                for (let i = 0; i < 6; i++) {
                    this.createPrimaryColorParticle();
                }
                
                // Hide victory panel
                document.getElementById('victoryPanel').style.display = 'none';
            }

            handleInteraction(result) {
                this.interactions++;
                
                if (result.type === 'fusion') {
                    this.particles = this.particles.filter(p => !result.removeParticles.includes(p));
                    this.particles.push(result.newParticle);
                } else if (result.type === 'explosion') {
                    this.particles = this.particles.filter(p => !result.removeParticles.includes(p));
                    this.particles.push(...result.newParticles);
                }
            }

            draw(ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ctx.globalCompositeOperation = 'screen';
                this.particles.forEach(particle => particle.draw(ctx));
                ctx.globalCompositeOperation = 'source-over';
                
                this.drawConnections(ctx);
            }

            drawConnections(ctx) {
                ctx.save();
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const p1 = this.particles[i];
                        const p2 = this.particles[j];
                        const distance = p1.distanceTo(p2);
                        const maxDistance = 150;
                        
                        if (distance < maxDistance) {
                            const alpha = (1 - distance / maxDistance) * 0.1;
                            ctx.strokeStyle = `rgba(135, 206, 235, ${alpha})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                }
                ctx.restore();
            }

            getParticleAt(x, y) {
                return this.particles.find(particle => particle.containsPoint(x, y));
            }

            addParticle(x, y) {
                // Create a random primary color particle when user taps/clicks
                const primaryColors = [
                    {r: 255, g: 0, b: 0},    // Red
                    {r: 0, g: 255, b: 0},    // Green
                    {r: 0, g: 0, b: 255},    // Blue
                ];
                const color = primaryColors[Math.floor(Math.random() * primaryColors.length)];
                
                this.particles.push(new Particle(x, y, {
                    density: 0.5, // All particles same size
                    color: color
                }));
            }

            performAutoAction() {
                if (this.particles.length < 20) {
                    // Add a new particle occasionally
                    if (Math.random() < 0.5) {
                        const x = 100 + Math.random() * (canvas.width - 200);
                        const y = 100 + Math.random() * (canvas.height - 200);
                        this.addParticle(x, y);
                    }
                }
                
                // Randomly explode large particles
                const largeParticles = this.particles.filter(p => p.density > 1.5);
                if (largeParticles.length > 0 && Math.random() < 0.3) {
                    const particle = largeParticles[Math.floor(Math.random() * largeParticles.length)];
                    const result = particle.explode();
                    if (result) {
                        this.handleInteraction(result);
                    }
                }
                
                // Nudge particles towards each other for more interactions (stronger in auto mode)
                if (this.particles.length > 1 && Math.random() < 0.8) {
                    const particle1 = this.particles[Math.floor(Math.random() * this.particles.length)];
                    const particle2 = this.particles[Math.floor(Math.random() * this.particles.length)];
                    if (particle1 !== particle2) {
                        const dx = particle2.x - particle1.x;
                        const dy = particle2.y - particle1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 0) {
                            const nudgeForce = 0.3; // Stronger nudging in auto mode
                            particle1.vx += (dx / distance) * nudgeForce;
                            particle1.vy += (dy / distance) * nudgeForce;
                        }
                    }
                }
            }

            getAverageColor() {
                if (this.particles.length === 0) return {r: 0, g: 0, b: 0};
                
                let totalR = 0, totalG = 0, totalB = 0, totalMass = 0;
                
                this.particles.forEach(particle => {
                    const mass = particle.mass;
                    totalR += particle.r * mass;
                    totalG += particle.g * mass;
                    totalB += particle.b * mass;
                    totalMass += mass;
                });
                
                if (totalMass === 0) return {r: 0, g: 0, b: 0};
                
                return {
                    r: Math.round(totalR / totalMass),
                    g: Math.round(totalG / totalMass),
                    b: Math.round(totalB / totalMass)
                };
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let particleSystem;
        let lastTime = 0;
        let draggedParticle = null;
        let mouseX = 0, mouseY = 0;
        let lastClickTime = 0;
        let lastClickedParticle = null;
        
        // Settings
        let attractionIntensity = 0.5; // 0 to 1
        let attractionRange = 200; // pixels
        let fusionProbability = 0.05; // 0 to 0.1
        let autoPlay = false;
        let autoPlayInterval = null;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            particleSystem.update(deltaTime);
            particleSystem.draw(ctx);

            const whiteProgress = Math.round(particleSystem.bestWhiteness * 100);
            document.getElementById('whiteProgress').textContent = `${whiteProgress}%`;
            
            // Update gauge color based on progress
            const gaugeCircle = document.querySelector('.gauge-circle');
            if (whiteProgress > 90) {
                gaugeCircle.style.background = 'conic-gradient(from 0deg, #ffffff 0%, #ffffff 100%)';
            } else if (whiteProgress > 70) {
                gaugeCircle.style.background = `conic-gradient(from 0deg, #ff0000 0%, #ffff00 33%, #00ff00 66%, #ffffff ${whiteProgress}%, #888 ${whiteProgress}%, #888 100%)`;
            } else {
                gaugeCircle.style.background = `conic-gradient(from 0deg, #ff0000 0%, #ffff00 33%, #00ff00 ${whiteProgress * 0.66}%, #888 ${whiteProgress * 0.66}%, #888 100%)`;
            }

            requestAnimationFrame(gameLoop);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        $(document).ready(function() {
            resizeCanvas();
            particleSystem = new ParticleSystem();
            
            $(window).resize(resizeCanvas);
            
            // Settings controls
            $('#attractionSlider').on('input', function() {
                attractionIntensity = parseFloat($(this).val()) / 100;
                $('#attractionValue').text($(this).val());
            });
            
            $('#rangeSlider').on('input', function() {
                attractionRange = parseFloat($(this).val());
                $('#rangeValue').text($(this).val());
            });
            
            $('#fusionSlider').on('input', function() {
                fusionProbability = parseFloat($(this).val()) / 100;
                $('#fusionValue').text($(this).val());
            });
            
            // Auto-play button
            $('#autoPlayBtn').on('click', function() {
                autoPlay = !autoPlay;
                const btn = $(this);
                if (autoPlay) {
                    btn.text('üõë ARR√äTER AUTO');
                    btn.css('background', 'linear-gradient(45deg, #f44336, #d32f2f)');
                } else {
                    btn.text('ü§ñ MODE AUTO');
                    btn.css('background', 'linear-gradient(45deg, #4CAF50, #45a049)');
                }
            });
            
            // Settings panel toggle
            $('#settingsIcon').on('click', function() {
                const panel = $('#settingsPanel');
                panel.toggle();
            });
            
            // Instructions panel toggle
            $('#helpIcon').on('click', function() {
                const panel = $('#instructionsPanel');
                panel.toggle();
            });
            
            // Replay button
            $('#replayButton').on('click', function() {
                particleSystem.resetGame();
            });
            
            // Click outside to close panels
            $(document).on('click', function(e) {
                if (!$(e.target).closest('#settingsIcon, #settingsPanel').length) {
                    $('#settingsPanel').hide();
                }
                if (!$(e.target).closest('#helpIcon, #instructionsPanel').length) {
                    $('#instructionsPanel').hide();
                }
            });

            // Mouse events
            $('#gameCanvas').on('mousedown', function(e) {
                if (e.which === 1) { // left click
                    const pos = getMousePos(e.originalEvent);
                    const clickedParticle = particleSystem.getParticleAt(pos.x, pos.y);
                    
                    if (clickedParticle) {
                        const currentTime = Date.now();
                        
                        // Check for double-click (within 300ms)
                        if (lastClickedParticle === clickedParticle && 
                            currentTime - lastClickTime < 300) {
                            // Double-click: explode particle
                            const result = clickedParticle.explode();
                            if (result) {
                                particleSystem.handleInteraction(result);
                            }
                            lastClickedParticle = null;
                            lastClickTime = 0;
                        } else {
                            // Single click: start dragging
                            draggedParticle = clickedParticle;
                            draggedParticle.isDragging = true;
                            canvas.style.cursor = 'grabbing';
                            
                            lastClickedParticle = clickedParticle;
                            lastClickTime = currentTime;
                        }
                    }
                }
            });

            $('#gameCanvas').on('contextmenu', function(e) {
                e.preventDefault();
                const pos = getMousePos(e.originalEvent);
                particleSystem.addParticle(pos.x, pos.y);
            });

            // Touch events for mobile
            $('#gameCanvas').on('touchstart', function(e) {
                e.preventDefault();
                const touch = e.originalEvent.touches[0];
                const pos = {
                    x: touch.clientX - canvas.getBoundingClientRect().left,
                    y: touch.clientY - canvas.getBoundingClientRect().top
                };
                
                const touchedParticle = particleSystem.getParticleAt(pos.x, pos.y);
                if (touchedParticle) {
                    const currentTime = Date.now();
                    
                    // Check for double-tap (within 400ms for touch)
                    if (lastClickedParticle === touchedParticle && 
                        currentTime - lastClickTime < 400) {
                        // Double-tap: explode particle
                        const result = touchedParticle.explode();
                        if (result) {
                            particleSystem.handleInteraction(result);
                        }
                        lastClickedParticle = null;
                        lastClickTime = 0;
                    } else {
                        // Single tap: start dragging
                        draggedParticle = touchedParticle;
                        draggedParticle.isDragging = true;
                        
                        lastClickedParticle = touchedParticle;
                        lastClickTime = currentTime;
                    }
                } else {
                    // Create new particle on empty space tap
                    particleSystem.addParticle(pos.x, pos.y);
                }
            });

            $('#gameCanvas').on('touchmove', function(e) {
                e.preventDefault();
                if (draggedParticle && e.originalEvent.touches.length > 0) {
                    const touch = e.originalEvent.touches[0];
                    const pos = {
                        x: touch.clientX - canvas.getBoundingClientRect().left,
                        y: touch.clientY - canvas.getBoundingClientRect().top
                    };
                    draggedParticle.x = pos.x;
                    draggedParticle.y = pos.y;
                    draggedParticle.vx = 0;
                    draggedParticle.vy = 0;
                    draggedParticle.energy = Math.min(1, draggedParticle.energy + 0.01);
                }
            });

            $('#gameCanvas').on('touchend', function(e) {
                e.preventDefault();
                if (draggedParticle) {
                    draggedParticle.isDragging = false;
                    draggedParticle = null;
                }
            });

            $(document).on('mousemove', function(e) {
                const pos = getMousePos(e.originalEvent);
                mouseX = pos.x;
                mouseY = pos.y;

                if (draggedParticle) {
                    draggedParticle.x = mouseX;
                    draggedParticle.y = mouseY;
                    draggedParticle.vx = 0;
                    draggedParticle.vy = 0;
                    draggedParticle.energy = Math.min(1, draggedParticle.energy + 0.01);
                }
            });

            $(document).on('mouseup', function() {
                if (draggedParticle) {
                    draggedParticle.isDragging = false;
                    draggedParticle = null;
                    canvas.style.cursor = 'crosshair';
                }
            });

            // Prevent default touch behaviors
            document.body.addEventListener('touchstart', function(e) {
                if (e.target === canvas) {
                    e.preventDefault();
                }
            }, { passive: false });

            document.body.addEventListener('touchend', function(e) {
                if (e.target === canvas) {
                    e.preventDefault();
                }
            }, { passive: false });

            document.body.addEventListener('touchmove', function(e) {
                if (e.target === canvas) {
                    e.preventDefault();
                }
            }, { passive: false });

            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>